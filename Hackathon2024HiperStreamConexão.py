# -*- coding: utf-8 -*-
"""Hackathon2024HiperStreamConexãoipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P7EtRSQFhTYdtw6444ziUyVkZWtBE4cy

**Hackathon 2024 da Escola de Engenharia (EE) da Universidade Presbiteriana Mackenzie (UPM)**

Códigos da equipe Conexão

Integrantes do grupo:


*   Amanda Pageu Silva
*   Gabriel Akira Wakavaiachi
*   Renan Yudi Fukumori

#Sem Comentário
"""

import graphviz as gz
import pandas as pd
import re

url = "https://raw.githubusercontent.com/gabakiwa/Hackathon/main/baseparateste-1.csv"
Base = pd.read_csv(url)

grafo = {}
dot = gz.Digraph(graph_attr={'rankdir': 'LR'})
for _, row in Base.iterrows():
    aplicacao = re.sub(r"[^\w:/-]", "", row["Nome"])
    origem = re.sub(r"\W", "", row["PastaOrigem"])
    destino =  re.sub(r"\W", "", row["PastaDestino"]) if not pd.isnull(row['PastaDestino']) else ""

    if backup is not None:

        if origem not in grafo:
            grafo[origem] = []

            label = f"{origem}\n{row['Nome']}"
            dot.node(origem, label=label)

        grafo[origem].append(destino)

        dot.node(destino)

for k, v in grafo.items():
    for n in v:
        dot.edge(k, n)

dot.attr(rank='same')
for i, node in enumerate(grafo.keys()):
    dot.attr(rank='same', _attributes={'rank': 'same', 'same': f'{node};'})

dot.render('OrigemDestino', format='pdf', cleanup=True)
print("Diagrama do grafo dividido em camadas verticais gerado com sucesso como 'OrigemDestino.pdf'")

import graphviz as gz
import pandas as pd
import re

url = "https://raw.githubusercontent.com/gabakiwa/Hackathon/main/baseparateste-1.csv"
Base = pd.read_csv(url)

grafo = {}
dot = gz.Digraph(graph_attr={'rankdir': 'LR'})
for _, row in Base.iterrows():
    aplicacao = re.sub(r"[^\w:/-]", "", row["Nome"])
    origem = re.sub(r"\W", "", row["PastaOrigem"])
    backup =  re.sub(r"\W", "", row["PastaBackup"]) if not pd.isnull(row['PastaBackup']) else ""

    if backup is not None:

        if origem not in grafo:
            grafo[origem] = []

            label = f"{origem}\n{row['Nome']}"
            dot.node(origem, label=label)

        grafo[origem].append(backup)

        dot.node(backup)

        grafo[origem].append(backup)

        dot.node(backup)

for k, v in grafo.items():
    for n in v:
        dot.edge(k, n)

dot.attr(rank='same')
for i, node in enumerate(grafo.keys()):
    dot.attr(rank='same', _attributes={'rank': 'same', 'same': f'{node};'})

dot.render('OrigemBackup', format='pdf', cleanup=True)
print("Diagrama do grafo dividido em camadas verticais gerado com sucesso como 'OrigemBackup.pdf'")

"""#Com Comentário"""

import graphviz as gz ##Importar a Biblioteca GraphViz para possibilitar construção dos Grafos
import pandas as pd ##Importar a Biblioteca Pandas para leitura do Gráfico
import re

url = "https://raw.githubusercontent.com/gabakiwa/Hackathon/main/baseparateste-1.csv" ##Carregar dados
Base = pd.read_csv(url) ##Colocar a base de dados em um DataFrame

grafo = {} ##Origem do Grafo, em lista de conjunto vazio
dot = gz.Digraph(graph_attr={'rankdir': 'LR'})  # Definição do layout hierárquico a partir OBS 1 e OBS 2
for _, row in Base.iterrows(): ##Iteração para cada linha da base de dados
    aplicacao = re.sub(r"[^\w:/-]", "", row["Nome"]) ##Leitura de cada linha da coluna "Nome", com exclusão de caracteres especiais exceto "-" e ":"
    origem = re.sub(r"\W", "", row["PastaOrigem"]) ##Leitura de cada linha da coluna "PastaOrigem", com exclusão de caracteres especiais OBS 3
    destino =  re.sub(r"\W", "", row["PastaDestino"]) if not pd.isnull(row['PastaDestino']) else ""  ##Leitura de cada linha da coluna "PastaDestino", com exclusão de caracteres especiais OBS 3

    # Inclusão de relação entre PastaOrigem e PastaDestino (se houver) OBS 4
    if destino is not None: ##Executa se PastaDestino não for célula vazia
        # Inclusão da PastaOrigem ao grafo se ainda não estiver presente
        if origem not in grafo: ##Se a PastaOrigem não estiver Grafo
            grafo[origem] = [] ##Se a PastaOrigem não estiver na lista do Grafo, é adicionada
            # Inclusão da apliicação da coluna Nome como um rótulo ao lado da PastaOrigem
            label = f"{origem}\n{row['Nome']}" ##Inclusão do Nome na label
            dot.node(origem, label=label) #Rótulo acrescentado ao nó

        grafo[origem].append(destino) # Acrréscimo do PastaDestino ao grafo

        dot.node(destino)  # Adicionar do nó de PastaDestino

for k, v in grafo.items(): #Itera um par de conjunto PastaOrigem->PastaDestino
    for n in v: ##Itera para cada PastaDestino
        dot.edge(k, n) #Criação da Conexão

dot.attr(rank='same') #Colocar nós na mesma direção
for i, node in enumerate(grafo.keys()): #Itera os dizeres da PastaOrigem
    dot.attr(rank='same', _attributes={'rank': 'same', 'same': f'{node};'}) ##Auxílio da organização dos nós na vertical

dot.render('OrigemDestino', format='pdf', cleanup=True) ##Renderizar o Grafo em um arquivo PDF OBS 5
print("Diagrama do grafo dividido em camadas verticais gerado com sucesso como 'OrigemDestino.pdf'") #Mensagem para sinalização da conclusão da geração do PDF

import graphviz as gz ##Importar a Biblioteca GraphViz para possibilitar construção dos Grafos
import pandas as pd ##Importar a Biblioteca Pandas para leitura do Gráfico

url = "https://raw.githubusercontent.com/gabakiwa/Hackathon/main/baseparateste-1.csv" ##Carregar dados
Base = pd.read_csv(url) ##Colocar a base de dados em um DataFrame

grafo = {} ##Origem do Grafo, em lista de conjunto vazio
dot = gz.Digraph(graph_attr={'rankdir': 'LR'})  # Definição do layout hierárquico a partir OBS 1 e OBS 2
for _, row in Base.iterrows(): ##Iteração para cada linha da base de dados
    aplicacao = re.sub(r"[^\w:/-]", "", row["Nome"]) ##Leitura de cada linha da coluna "Nome", com exclusão de caracteres especiais exceto "-" e ":"
    origem = re.sub(r"\W", "", row["PastaOrigem"]) ##Leitura de cada linha da coluna "PastaOrigem", com exclusão de caracteres especiais OBS 3
    backup =  re.sub(r"\W", "", row["PastaBackup"]) if not pd.isnull(row['PastaBackup']) else ""  ##Leitura de cada linha da coluna "PastaBackup", com exclusão de caracteres especiais OBS 3

    # Inclusão de relação entre PastaOrigem e PastaBackup (se houver) OBS 4
    if backup is not None: ##Executa se BackUp não for célula vazia
        # Inclusão da PastaOrigem ao grafo se ainda não estiver presente
        if origem not in grafo: ##Se a PastaOrigem não estiver Grafo
            grafo[origem] = [] ##Se a PastaOrigem não estiver na lista do Grafo, é adicionada
            # Inclusão da apliicação da coluna Nome como um rótulo ao lado da PastaOrigem
            label = f"{origem}\n{row['Nome']}" ##Inclusão do Nome na label
            dot.node(origem, label=label) #Rótulo acrescentado ao nó

        grafo[origem].append(backup) # Acrréscimo do backup ao grafo

        dot.node(backup)  # Adicionar do nó de backup

for k, v in grafo.items(): #Itera um par de conjunto PastaOrigem->PastaBackUp
    for n in v: ##Itera para cada BackUp
        dot.edge(k, n) #Criação da Conexão

dot.attr(rank='same') #Colocar nós na mesma direção
for i, node in enumerate(grafo.keys()): #Itera os dizeres da PastaOrigem
    dot.attr(rank='same', _attributes={'rank': 'same', 'same': f'{node};'}) ##Auxílio da organização dos nós na vertical

dot.render('OrigemBackup', format='pdf', cleanup=True) ##Renderizar o Grafo em um arquivo PDF OBS 5
print("Diagrama do grafo dividido em camadas verticais gerado com sucesso como 'OrigemBackup.pdf'") #Mensagem para sinalização da conclusão da geração do PDF

"""**OBS 1** : para a análise da atribuição do layout hierarquico, vale ressaltar que, por melhor visualização do grafo gerado, se deu preferência ao LR (*Left to Right*) em detretimento de TB (*Top to Bottom*).
Em uma visualização orientada na vertical se tem maior controla da largura da imagem, o que facilita sua manipulação caso necessário.

**OBS 2** : optou-se, para a construção do grafo, pela biblioteca GraphViz pela sua praticidade e adaptação ao código elaborado. Foram aventadas outras alternativas, como MatPlotLib e NetworkX, para execução mas, devido ao layout limitado que ambas oferecem e que não eram do propósito de apresentação, foram excluidas.

**OBS 3** : devido a presença do caractere "\\" na base de dados, se teve dificuldade em encontrar uma alternativa possível de contornar o erro de leitura que se tem no código caso não exclua. Para tanto, foram realizados, infelizmente sem sucesso, testes para contornar o problema.
Uma das alternativas mais 'plausiveis' foi a consideração da substituição de "\\" por, exclusivamente,  "_", uma vez demais caracteres impossibilitavam a conclusão do código. O problema identificado foi o de desformatação do grafo após a geração do PDF.

**OBS 4** : se tem o auxílio para que não exista conflito de informações e/ou erro no código caso se identifique uma eventual célula vazia.

**OBS 5** : ao pensar na praticidade e melhor visualização, optou-se pelo formato .PDF. Assim, espera-se facilitar não somente a utilidade do grafo mas também no compartilhamento dos arquivos uma vez que, por vezes, pode se ter o cenário de dificuldade para abertura da imagem.
"""